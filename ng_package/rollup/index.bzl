load("//ng_package/rollup:utils.bzl", 
  "WELL_KNOWN_EXTERNALS",
  "serialize_file",
  "find_matching_file",
  "filter_esm_files_to_include",
  "serialize_files_for_arg"
)
load("@aspect_rules_js//js:providers.bzl", "JsInfo")
load("//ng_project/config:compilation_mode.bzl", "partial_compilation_transition")
load("//ng_package/bundle_types:index.bzl", "bundle_type_declaration")

# Prints a debug message if "--define=VERBOSE_LOGS=true" is specified.
def _debug(vars, *args):
    if "VERBOSE_LOGS" in vars.keys():
        print("[ApfRollup] ", args)



def _ng_package_rollup_impl(ctx):
  npm_package_directory = ctx.actions.declare_directory("%s.ng_pkg" % ctx.label.name)
  owning_package = ctx.label.package

  # The name of the primary entry-point FESM bundles, computed name from the owning package
  # e.g. For `packages/core:npm_package`, the name is resolved to be `core`.
  primary_bundle_name = owning_package.split("/")[-1]

  # Static files are files which are simply copied over into the tree artifact. These files
  # are not picked up by the entry-point bundling etc. Can also be generated by e.g. a genrule.
  static_files = []

  # Collect static files, and skip files outside of the current owning package.
  for file in ctx.files.srcs:
      if file.short_path.startswith(owning_package):
        static_files.append(file)
      else:
        _debug(ctx.var, "File %s is defined outside of %s but part of `srcs`, skipping." % (file, owning_package))

  type_files = []

  # List of unscoped direct and transitive ESM sources that are provided
  # by all entry-points.
  unscoped_all_entry_point_esm2022 = []

  # We infer the entry points to be:
  # - ng_module rules in the deps (they have an "angular" provider)
  # - in this package or a subpackage
  # - those that have a module_name attribute (they produce flat module metadata)
  collected_entry_points = []

  # Name of the NPM package. The name is computed as we iterate through all
  # dependencies of the `ng_package`.
  npm_package_name = None

  for dep in ctx.attr.srcs:
      if not dep.label.package.startswith(owning_package):
          fail("Unexpected dependency. %s is defined outside of %s." % (dep, owning_package))

      # Module name of the current entry-point. eg. @angular/core/testing
      module_name = ""

      # Package name where this entry-point is defined in,
      entry_point_package = dep.label.package

      # Intentionally evaluates to empty string for the main entry point
      entry_point = entry_point_package[len(owning_package) + 1:]

      # Whether this dependency is for the primary entry-point of the package.
      is_primary_entry_point = entry_point == ""

      # Collect ESM2022 and type definition source files from the dependency, including
      # transitive sources which are not directly defined in the entry-point. This is
      # necessary to allow for entry-points to rely on sub-targets (as a perf improvement).
      unscoped_esm2022_depset = dep[JsInfo].sources
      unscoped_types_depset = dep[JsInfo].transitive_types
      unscoped_all_entry_point_esm2022.append(unscoped_esm2022_depset)

      # Extract the "module_name" from either "ts_library" or "ng_module". Both
      # set the "module_name" in the provider struct.
      #if hasattr(dep, "module_name"):
      #    module_name = dep.module_name
      #elif LinkablePackageInfo in dep:
      #    # Modern `ts_project` interop targets don't make use of legacy struct
      #    # providers, and instead encapsulate the `module_name` in an idiomatic provider.
      #    module_name = dep[LinkablePackageInfo].package_name

      if is_primary_entry_point:
          npm_package_name = module_name

      if hasattr(dep, "angular") and hasattr(dep.angular, "flat_module_metadata"):
          # For dependencies which are built using the "ng_module" with flat module bundles
          # enabled, we determine the module name, the flat module index file, the metadata
          # file and the typings entry point from the flat module metadata which is set by
          # the "ng_module" rule.
          ng_module_metadata = dep.angular.flat_module_metadata
          module_name = ng_module_metadata.module_name
          es2022_entry_point = ng_module_metadata.flat_module_out_prodmode_file
          typings_entry_point = ng_module_metadata.typings_file
          guessed_paths = False

          _debug(
              ctx.var,
              "entry-point %s is built using a flat module bundle." % dep,
              "using %s as main file of the entry-point" % es2022_entry_point,
          )
      else:
          _debug(
              ctx.var,
              "entry-point %s does not have flat module metadata." % dep,
              "guessing `index.mjs` as main file of the entry-point",
          )

          # Note: Using `to_list()` is expensive but we cannot get around this here as
          # we need to filter out generated files and need to be able to iterate through
          # typing files in order to determine the entry-point type file.
          unscoped_types = unscoped_types_depset.to_list()

          # Note: Using `to_list()` is expensive but we cannot get around this here as
          # we need to filter out generated files to be able to detect entry-point index
          # files when no flat module metadata is available.
          unscoped_esm2022_list = unscoped_esm2022_depset.to_list()

          # In case the dependency is built through the "ts_library" rule, or the "ng_module"
          # rule does not generate a flat module bundle, we determine the index file and
          # typings entry-point through the most reasonable defaults (i.e. "package/index").
          es2022_entry_point = find_matching_file(
              unscoped_esm2022_list,
              [
                  "%s/index.mjs" % entry_point_package,
                  # Fallback for `ts_project` support where `.mjs` is not auto-generated.
                  "%s/index.js" % entry_point_package,
              ],
          )
          typings_entry_point = find_matching_file(unscoped_types, ["%s/index.d.ts" % entry_point_package])
          guessed_paths = True

      bundle_name = "%s.mjs" % (primary_bundle_name if is_primary_entry_point else entry_point)
      fesm2022_file = "fesm2022/%s" % bundle_name

      # By default, we will bundle the typings entry-point, unless explicitly opted-out
      # through the `skip_type_bundling` rule attribute.
      if entry_point in ctx.attr.skip_type_bundling:
          if typings_entry_point.short_path != "%s/index.d.ts" % entry_point_package:
              fail(("Type bundling is explicitly disabled for `%s`, expected manual " +
                    "`%s/index.d.ts` to be provided.") % (entry_point, entry_point_package))

          typings_file = typings_entry_point
      else:
          # Note: To avoid conflicts with source-file generated `index.d.ts` files we prefix the
          # bundle typings file and remove the prefix later when assembling the package.
          typings_file = ctx.actions.declare_file("%s__index.d.ts" % ("%s/" % entry_point if entry_point else ""))

          bundle_type_declaration(
              ctx = ctx,
              output_file = typings_file,
              entry_point = typings_entry_point,
              license_banner_file = ctx.file.license_banner,
              types = unscoped_types_depset,
          )

      type_files.append(typings_file)

      # Store the collected entry point in a list of all entry-points. This
      # can be later passed to the packager as a manifest.
      collected_entry_points.append(struct(
          module_name = module_name,
          es2022_entry_point = es2022_entry_point,
          fesm2022_file = fesm2022_file,
          typings_file = typings_file,
          guessed_paths = guessed_paths,
      ))

  # Note: Using `to_list()` is expensive but we cannot get around this here as
  # we need to filter out generated files and need to be able to iterate through
  # JavaScript files in order to capture the relevant package-owned `esm2022/` in the APF.
  unscoped_all_entry_point_esm2022_depset = depset(transitive = unscoped_all_entry_point_esm2022)
  unscoped_all_entry_point_esm2022_list = unscoped_all_entry_point_esm2022_depset.to_list()

  # Filter ESM2022 JavaScript inputs to files which are part of the owning package. The
  # packager should not copy external files into the package.
  esm2022 = filter_esm_files_to_include(unscoped_all_entry_point_esm2022_list, owning_package)

  packager_inputs = (
      static_files +
      type_files +
      esm2022
  )

  packager_args = ctx.actions.args()
  packager_args.use_param_file("%s", use_always = True)

  # The order of arguments matters here, as they are read in order in packager.ts.
  #packager_args.add(npm_package_directory.path)
  packager_args.add(ctx.label.package)

  # Marshal the metadata into a JSON string so we can parse the data structure
  # in the TypeScript program easily.
  metadata_arg = {}
  for m in collected_entry_points:
      # The captured properties need to match the `EntryPointInfo` interface
      # in the packager executable tool.
      metadata_arg[m.module_name] = {
          "index": serialize_file(m.es2022_entry_point),
          "fesm2022RelativePath": m.fesm2022_file,
          "typings": serialize_file(m.typings_file),
          # If the paths for that entry-point were guessed (e.g. "ts_library" rule or
          # "ng_module" without flat module bundle), we pass this information to the packager.
          "guessedPaths": m.guessed_paths,
      }

  for ep in ctx.attr.side_effect_entry_points:
      if not metadata_arg[ep]:
          known_entry_points = ",".join([e.module_name for e in collected_entry_points])
          fail("Unknown entry-point (%s) specified to include side effects. " % ep +
                "The following entry-points are known: %s" % known_entry_points)


  rollup_config = _write_rollup_config(ctx)



  rollup_inputs = depset(static_files, transitive = [unscoped_all_entry_point_esm2022_depset])
  bundles_out = ctx.actions.declare_directory("%s_fesm_bundle_out" % ctx.label.name)

  args = ctx.actions.args()
  args.add("--config", rollup_config)
  args.add("--output.format", "esm")
  args.add("--output.dir", bundles_out.path + "/fesm2022")

  # Note: if the input has external source maps then we need to also install and use
  #   `rollup-plugin-sourcemaps`, which will require us to use rollup.config.js file instead
  #   of command line args
  args.add("--sourcemap")

  args.add("--preserveSymlinks")

  # We will produce errors as needed. Anything else is spammy: a well-behaved
  # bazel rule prints nothing on success.
  args.add("--silent")

  other_inputs = [rollup_config]
  if ctx.file.license_banner:
      other_inputs.append(ctx.file.license_banner)
  ctx.actions.run(
      progress_message = "ng_package: Rollup %s" % (ctx.label),
      mnemonic = "AngularPackageRollup",
      inputs = depset(other_inputs, transitive = [rollup_inputs]),
      outputs = [bundles_out],
      executable = ctx.executable._rollup_bin,
      tools = [ctx.executable._rollup_bin],
      arguments = [args],
      env = {
          "BAZEL_BINDIR": ".",
      },
  )

  packager_inputs.append(bundles_out)

  # Encodes the package metadata with all its entry-points into JSON so that
  # it can be deserialized by the packager tool. The struct needs to match with
  # the `PackageMetadata` interface in the packager tool.
  packager_args.add(json.encode(struct(
      npmPackageName = npm_package_name,
      entryPoints = metadata_arg,
      bundlesOut = serialize_file(bundles_out),
  )))

  if ctx.file.readme_md:
      packager_inputs.append(ctx.file.readme_md)
      packager_args.add(ctx.file.readme_md.path)
  else:
      # placeholder
      packager_args.add("")

  if ctx.file.license:
      packager_inputs.append(ctx.file.license)
      packager_args.add(ctx.file.license.path)
  else:
      #placeholder
      packager_args.add("")

  packager_args.add(serialize_files_for_arg(esm2022))
  packager_args.add(serialize_files_for_arg(static_files))
  packager_args.add(serialize_files_for_arg(type_files))

  packager_args.add(json.encode(ctx.attr.side_effect_entry_points))

  ctx.actions.run(
      progress_message = "Angular Packaging: building npm package %s" % str(ctx.label),
      mnemonic = "AngularPackage",
      inputs = packager_inputs,
      outputs = [npm_package_directory],
      executable = ctx.executable._packager_bin,
      arguments = [packager_args],
      env = {
          "BAZEL_BINDIR": ".",
      },
  )

  return [
    DefaultInfo(files = depset([npm_package_directory]))
  ]



ng_package_rollup = rule(
  implementation = _ng_package_rollup_impl,
  attrs = {    
    "side_effect_entry_points": attr.string_list(
        doc = "List of entry-points that have top-level side-effects",
        default = [],
    ),
    "deps": attr.label_list(
        doc = """ Targets that produce production JavaScript outputs, such as `ts_library`.""",
        cfg = partial_compilation_transition,
    ),
    "srcs": attr.label_list(
        doc = """JavaScript source files from the workspace.
        These can use ES2022 syntax and ES Modules (import/export)""",
        cfg = partial_compilation_transition,
        allow_files = True,
    ),
    "externals": attr.string_list(
        doc = """List of external module that should not be bundled into the flat ESM bundles.""",
        default = [],
    ),
    "license_banner": attr.label(
        doc = """A .txt file passed to the `banner` config option of rollup.
        The contents of the file will be copied to the top of the resulting bundles.
        Configured substitutions are applied like with other files in the package.""",
        allow_single_file = [".txt"],
    ),
    "readme_md": attr.label(allow_single_file = [".md"]),
    "license": attr.label(
        doc = """A textfile that will be copied to the root of the npm package.""",
        allow_single_file = True,
    ),

    "skip_type_bundling": attr.string_list(
        default = [],
        doc = """
          List of entry-points for which type bundle generation should be skipped. Requires a
          self-contained `index.d.ts` to be generated (i.e. with no relative imports).

          Skipping of bundling might be desirable due to limitations in Microsoft's API extractor.
          For example when `declare global` is used: https://github.com/microsoft/rushstack/issues/2090.

          ```
              "",                # Skips the primary entry-point from bundling.
              "testing",         # Skips the testing entry-point from type bundling
              "select/testing",  # Skips the `select/testing` entry-point
          ```
        """,
    ),

    "_rollup_config_tmpl": attr.label(
        default = Label("//ng_package/rollup:rollup.config.js"),
        allow_single_file = True,
    ),

    
    "_types_bundler_bin": attr.label(
        default = Label("//ng_package/bundle_types:bin"),
        cfg = "exec",
        executable = True,
    ),
    "_rollup_bin": attr.label(
        default = Label("//ng_package/rollup:rollup"),
        cfg = "exec",
        executable = True,
    ),
    "_packager_bin": attr.label(
        default = Label("//ng_package/packager:packager"),
        cfg = "exec",
        executable = True,
    ),

    # Needed in order to allow for the outgoing transition on the `deps` attribute.
    # https://docs.bazel.build/versions/main/skylark/config.html#user-defined-transitions.
    "_allowlist_function_transition": attr.label(
        default = "@bazel_tools//tools/allowlists/function_transition_allowlist",
    ),
  }
)



def _write_rollup_config(ctx):
  config = ctx.actions.declare_file("_%s.rollup.conf.js" % ctx.label.name)


  # We infer the entry points to be:
  # - ng_module rules in the deps (they have an "angular" provider)
  # - in this package or a subpackage
  # - those that have a module_name attribute (they produce flat module metadata)
  collected_entry_points = []

  
  
  # Marshal the metadata into a JSON string so we can parse the data structure
  # in the TypeScript program easily.
  metadata_arg = {}
  for m in collected_entry_points:
      # The captured properties need to match the `EntryPointInfo` interface
      # in the packager executable tool.
      metadata_arg[m.module_name] = {
          "index": serialize_file(m.es2022_entry_point),
          "fesm2022RelativePath": m.fesm2022_file,
          "typings": serialize_file(m.typings_file),
          # If the paths for that entry-point were guessed (e.g. "ts_library" rule or
          # "ng_module" without flat module bundle), we pass this information to the packager.
          "guessedPaths": m.guessed_paths,
      }

  for ep in ctx.attr.side_effect_entry_points:
      if not metadata_arg[ep]:
          known_entry_points = ",".join([e.module_name for e in collected_entry_points])
          fail("Unknown entry-point (%s) specified to include side effects. " % ep +
                "The following entry-points are known: %s" % known_entry_points)

  print(metadata_arg)
  mappings = build_mappings_for_entry_points(ctx)
    
    
  #all_deps = ctx.attr.deps + ctx.attr.srcs
  #for dep in all_deps:
  #    if hasattr(dep, _NG_PACKAGE_MODULE_MAPPINGS_ATTR):
  #        for k, v in getattr(dep, _NG_PACKAGE_MODULE_MAPPINGS_ATTR).items():
  #            if k in mappings and mappings[k] != v:
  #                fail(("duplicate module mapping at %s: %s maps to both %s and %s" %
  #                      (dep.label, k, mappings[k], v)), "deps")
  #            mappings[k] = v

  externals = WELL_KNOWN_EXTERNALS + ctx.attr.externals

  # Pass external & globals through a templated config file because on Windows there is
  # an argument limit and we there might be a lot of globals which need to be passed to
  # rollup.

  ctx.actions.expand_template(
      output = config,
      template = ctx.file._rollup_config_tmpl,
      substitutions = {
          "TMPL_banner_file": "\"%s\"" % ctx.file.license_banner.path if ctx.file.license_banner else "undefined",
          "TMPL_module_mappings": str(mappings),
          # TODO: Figure out node_modules root
          "TMPL_node_modules_root": "node_modules",
          "TMPL_metadata": json.encode(metadata_arg),
          "TMPL_root_dir": ctx.bin_dir.path,
          "TMPL_workspace_name": ctx.workspace_name,
          "TMPL_external": ", ".join(["'%s'" % e for e in externals]),
          "TMPL_side_effect_entrypoints": json.encode(ctx.attr.side_effect_entry_points),
      },
  )
  
  return config


def build_mappings_for_entry_points(ctx):
  package_base = ctx.label.package
  entry_points = determine_entry_points(ctx)
  mappings = {}
  for entry_point in entry_points:
    print(entry_point)
    module_name = ''
    mappings[module_name] = entry_point.short_path[:-len('/index.js')]

  return mappings



def determine_entry_points(ctx):
  """Determine all of the entry points to be available within the angular package.
  We investigate each provided target as each target can only provide one entry point. This
  prevents us accidently creating an entry point at an unintended/unexpected level.

  Args:
    srcs: A list of targets to extract entry points from.

  Returns:
    A list of files which represent the list of all entrypoints for the angular package.
  """
  entry_points = []
  for target in ctx.attr.srcs:
    entry_point = None
    if target[JsInfo]:
      for file in target[JsInfo].sources.to_list():
        if _is_part_of_package(ctx, file) and file.basename == 'index.js':
          entry_point = file
          break
    if entry_point == None:
      fail("No entry point (index.js) file provided in %s" % target)
    
    entry_points.append(entry_point)

  return entry_points

def _is_part_of_package(ctx, file):
  """Determine whether the provided file is part of the package being built.

  Args:
    file: String of the file path
  
  Returns:
    A boolean of whether the file is part of the package.
  """
  return file.short_path.startswith(ctx.label.package)

